/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include "Utils.h"

#include <algorithm>
#include <string>

#include <parse/t_base_type.h>
#include <parse/t_field.h>
#include <parse/t_program.h>
#include <parse/t_type.h>

#include "version.h"

using namespace apache::thrift::compiler::generate;

namespace {
std::string replaceAllDots(std::string s, const std::string& with) {
  const char dot = '.';
  for (auto i = s.rfind(dot); i != std::string::npos; i = s.rfind(dot, i))
    s.replace(i, 1, with);

  return s;
}
}

std::string cpp_v2::namespaceOpen(const std::string& name) {
  return "namespace " + replaceAllDots(name, " { namespace ") + " {";
}

std::string cpp_v2::namespaceClose(const std::string& name) {
  const auto count = std::count(name.begin(), name.end(), '.');
  return std::string(count + 1, '}') + " // namespace " + namespaceName(name);
}

std::string cpp_v2::namespaceName(const std::string& name) {
  return replaceAllDots(name, "::");
}

std::string cpp_v2::namespacePrefix(const std::string& name) {
  if (name.empty())
    return name;
  return "::" + namespaceName(name) + "::";
}

std::string cpp_v2::autogenComment() {
  return "/**\n"
         " * Autogenerated by Thrift Compiler (" THRIFT_VERSION
         ")\n"
         " *\n"
         " * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n"
         " *  @generated\n"
         " */\n";
}

std::string cpp_v2::getCppNamespace(const t_type* type) {
  if (type->get_program())
    return type->get_program()->get_namespace("cpp");
  return std::string();
}

bool cpp_v2::isUserDefinedType(const t_type* type) {
  return type->is_enum() || type->is_struct() || type->is_xception() || type->is_service()
         || type->is_typedef();
}

std::string cpp_v2::getTTypeString(const t_type* type) {
  type = type->get_true_type();

  if (type->is_base_type()) {
    auto base = static_cast<const t_base_type*>(type)->get_base();
    switch (base) {
    case t_base_type::TYPE_VOID:
      return "::apache::thrift::protocol::T_VOID";
    case t_base_type::TYPE_BOOL:
      return "::apache::thrift::protocol::T_BOOL";
    case t_base_type::TYPE_BYTE:
      return "::apache::thrift::protocol::T_BYTE";
    case t_base_type::TYPE_DOUBLE:
      return "::apache::thrift::protocol::T_DOUBLE";
    case t_base_type::TYPE_I16:
      return "::apache::thrift::protocol::T_I16";
    case t_base_type::TYPE_I32:
      return "::apache::thrift::protocol::T_I32";
    case t_base_type::TYPE_I64:
      return "::apache::thrift::protocol::T_I64";
    case t_base_type::TYPE_STRING:
      return "::apache::thrift::protocol::T_STRING";
    }
  }

  if (type->is_list())
    return "::apache::thrift::protocol::T_LIST";
  if (type->is_set())
    return "::apache::thrift::protocol::T_SET";
  if (type->is_map())
    return "::apache::thrift::protocol::T_MAP";

  if (type->is_enum())
    return "::apache::thrift::protocol::T_I32";

  if (type->is_struct())
    return "::apache::thrift::protocol::T_STRUCT";
  if (type->is_xception())
    return "::apache::thrift::protocol::T_STRUCT";

  throw "INVALID TYPE IN getTTypeString: " + type->get_name();
}

std::string cpp_v2::getReadWriteSuffix(const t_base_type* type) {
  switch (type->get_base()) {
  case t_base_type::TYPE_VOID:
    throw std::string("VOID type in read/write");
  case t_base_type::TYPE_BOOL:
    return "Bool";
  case t_base_type::TYPE_BYTE:
    return "Byte";
  case t_base_type::TYPE_DOUBLE:
    return "Double";
  case t_base_type::TYPE_I16:
    return "I16";
  case t_base_type::TYPE_I32:
    return "I32";
  case t_base_type::TYPE_I64:
    return "I64";
  case t_base_type::TYPE_STRING:
    return "String";
  }

  throw "INVALID TYPE IN getReadWriteSuffix: " + type->get_name();
}

static std::size_t uniqueNameGenerator = 0;

void cpp_v2::resetUniqueNameGenerator() {
  uniqueNameGenerator = 0;
}

std::string cpp_v2::makeUniqueName(const std::string& nameTemplate) {
  return nameTemplate + std::to_string(uniqueNameGenerator++);
}

std::string cpp_v2::namespaceOpen(const t_type* type) {
  return namespaceOpen(getCppNamespace(type));
}

std::string cpp_v2::namespaceClose(const t_type* type) {
  return namespaceClose(getCppNamespace(type));
}

std::string cpp_v2::namespaceName(const t_type* type) {
  return namespaceName(getCppNamespace(type));
}

std::string cpp_v2::namespacePrefix(const t_type* type) {
  return namespacePrefix(getCppNamespace(type));
}

std::string cpp_v2::namespacePrefixIfDifferent(const std::string& base, const std::string& other) {
  return (base != other) ? namespacePrefix(other) : std::string();
}

std::string cpp_v2::namespacePrefixIfDifferent(const t_type* referenceType,
                                               const t_type* prefixedType) {
  return namespacePrefixIfDifferent(getCppNamespace(referenceType), getCppNamespace(prefixedType));
}

std::string cpp_v2::localInclude(const std::string& fileName) {
  return "#include \"" + fileName + '"';
}

std::string cpp_v2::systemInclude(const std::string& fileName) {
  return "#include <" + fileName + '>';
}

bool cpp_v2::isBasicType(const t_type* type) {
  type = type->get_true_type();
  return (type->is_base_type() && !type->is_string()) || type->is_enum();
}

bool cpp_v2::isResultSpecialField(const t_field* field) {
  return field->get_key() == 0 && field->get_name() == "success";
}
